// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: user.proto

package arb_protos

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on CreateUserRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CreateUserRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateUserRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateUserRequestMultiError, or nil if none found.
func (m *CreateUserRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateUserRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetName()) < 3 {
		err := CreateUserRequestValidationError{
			field:  "Name",
			reason: "value length must be at least 3 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if err := m._validateEmail(m.GetEmail()); err != nil {
		err = CreateUserRequestValidationError{
			field:  "Email",
			reason: "value must be a valid email address",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetPassword()) < 8 {
		err := CreateUserRequestValidationError{
			field:  "Password",
			reason: "value length must be at least 8 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return CreateUserRequestMultiError(errors)
	}

	return nil
}

func (m *CreateUserRequest) _validateHostname(host string) error {
	s := strings.ToLower(strings.TrimSuffix(host, "."))

	if len(host) > 253 {
		return errors.New("hostname cannot exceed 253 characters")
	}

	for _, part := range strings.Split(s, ".") {
		if l := len(part); l == 0 || l > 63 {
			return errors.New("hostname part must be non-empty and cannot exceed 63 characters")
		}

		if part[0] == '-' {
			return errors.New("hostname parts cannot begin with hyphens")
		}

		if part[len(part)-1] == '-' {
			return errors.New("hostname parts cannot end with hyphens")
		}

		for _, r := range part {
			if (r < 'a' || r > 'z') && (r < '0' || r > '9') && r != '-' {
				return fmt.Errorf("hostname parts can only contain alphanumeric characters or hyphens, got %q", string(r))
			}
		}
	}

	return nil
}

func (m *CreateUserRequest) _validateEmail(addr string) error {
	a, err := mail.ParseAddress(addr)
	if err != nil {
		return err
	}
	addr = a.Address

	if len(addr) > 254 {
		return errors.New("email addresses cannot exceed 254 characters")
	}

	parts := strings.SplitN(addr, "@", 2)

	if len(parts[0]) > 64 {
		return errors.New("email address local phrase cannot exceed 64 characters")
	}

	return m._validateHostname(parts[1])
}

// CreateUserRequestMultiError is an error wrapping multiple validation errors
// returned by CreateUserRequest.ValidateAll() if the designated constraints
// aren't met.
type CreateUserRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateUserRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateUserRequestMultiError) AllErrors() []error { return m }

// CreateUserRequestValidationError is the validation error returned by
// CreateUserRequest.Validate if the designated constraints aren't met.
type CreateUserRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateUserRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateUserRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateUserRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateUserRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateUserRequestValidationError) ErrorName() string {
	return "CreateUserRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateUserRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateUserRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateUserRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateUserRequestValidationError{}

// Validate checks the field values on CreateUserResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateUserResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateUserResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateUserResponseMultiError, or nil if none found.
func (m *CreateUserResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateUserResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Success

	// no validation rules for Id

	// no validation rules for Message

	// no validation rules for Error

	if len(errors) > 0 {
		return CreateUserResponseMultiError(errors)
	}

	return nil
}

// CreateUserResponseMultiError is an error wrapping multiple validation errors
// returned by CreateUserResponse.ValidateAll() if the designated constraints
// aren't met.
type CreateUserResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateUserResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateUserResponseMultiError) AllErrors() []error { return m }

// CreateUserResponseValidationError is the validation error returned by
// CreateUserResponse.Validate if the designated constraints aren't met.
type CreateUserResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateUserResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateUserResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateUserResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateUserResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateUserResponseValidationError) ErrorName() string {
	return "CreateUserResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateUserResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateUserResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateUserResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateUserResponseValidationError{}

// Validate checks the field values on UpdateUserRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UpdateUserRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateUserRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateUserRequestMultiError, or nil if none found.
func (m *UpdateUserRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateUserRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if utf8.RuneCountInString(m.GetName()) < 3 {
		err := UpdateUserRequestValidationError{
			field:  "Name",
			reason: "value length must be at least 3 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if err := m._validateEmail(m.GetEmail()); err != nil {
		err = UpdateUserRequestValidationError{
			field:  "Email",
			reason: "value must be a valid email address",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Jwt

	if len(errors) > 0 {
		return UpdateUserRequestMultiError(errors)
	}

	return nil
}

func (m *UpdateUserRequest) _validateHostname(host string) error {
	s := strings.ToLower(strings.TrimSuffix(host, "."))

	if len(host) > 253 {
		return errors.New("hostname cannot exceed 253 characters")
	}

	for _, part := range strings.Split(s, ".") {
		if l := len(part); l == 0 || l > 63 {
			return errors.New("hostname part must be non-empty and cannot exceed 63 characters")
		}

		if part[0] == '-' {
			return errors.New("hostname parts cannot begin with hyphens")
		}

		if part[len(part)-1] == '-' {
			return errors.New("hostname parts cannot end with hyphens")
		}

		for _, r := range part {
			if (r < 'a' || r > 'z') && (r < '0' || r > '9') && r != '-' {
				return fmt.Errorf("hostname parts can only contain alphanumeric characters or hyphens, got %q", string(r))
			}
		}
	}

	return nil
}

func (m *UpdateUserRequest) _validateEmail(addr string) error {
	a, err := mail.ParseAddress(addr)
	if err != nil {
		return err
	}
	addr = a.Address

	if len(addr) > 254 {
		return errors.New("email addresses cannot exceed 254 characters")
	}

	parts := strings.SplitN(addr, "@", 2)

	if len(parts[0]) > 64 {
		return errors.New("email address local phrase cannot exceed 64 characters")
	}

	return m._validateHostname(parts[1])
}

// UpdateUserRequestMultiError is an error wrapping multiple validation errors
// returned by UpdateUserRequest.ValidateAll() if the designated constraints
// aren't met.
type UpdateUserRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateUserRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateUserRequestMultiError) AllErrors() []error { return m }

// UpdateUserRequestValidationError is the validation error returned by
// UpdateUserRequest.Validate if the designated constraints aren't met.
type UpdateUserRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateUserRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateUserRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateUserRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateUserRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateUserRequestValidationError) ErrorName() string {
	return "UpdateUserRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateUserRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateUserRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateUserRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateUserRequestValidationError{}

// Validate checks the field values on UpdateUserResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateUserResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateUserResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateUserResponseMultiError, or nil if none found.
func (m *UpdateUserResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateUserResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Success

	// no validation rules for Message

	// no validation rules for Error

	if len(errors) > 0 {
		return UpdateUserResponseMultiError(errors)
	}

	return nil
}

// UpdateUserResponseMultiError is an error wrapping multiple validation errors
// returned by UpdateUserResponse.ValidateAll() if the designated constraints
// aren't met.
type UpdateUserResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateUserResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateUserResponseMultiError) AllErrors() []error { return m }

// UpdateUserResponseValidationError is the validation error returned by
// UpdateUserResponse.Validate if the designated constraints aren't met.
type UpdateUserResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateUserResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateUserResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateUserResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateUserResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateUserResponseValidationError) ErrorName() string {
	return "UpdateUserResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateUserResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateUserResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateUserResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateUserResponseValidationError{}

// Validate checks the field values on Permission with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Permission) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Permission with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PermissionMultiError, or
// nil if none found.
func (m *Permission) ValidateAll() error {
	return m.validate(true)
}

func (m *Permission) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetName()) < 3 {
		err := PermissionValidationError{
			field:  "Name",
			reason: "value length must be at least 3 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Id

	if len(errors) > 0 {
		return PermissionMultiError(errors)
	}

	return nil
}

// PermissionMultiError is an error wrapping multiple validation errors
// returned by Permission.ValidateAll() if the designated constraints aren't met.
type PermissionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PermissionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PermissionMultiError) AllErrors() []error { return m }

// PermissionValidationError is the validation error returned by
// Permission.Validate if the designated constraints aren't met.
type PermissionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PermissionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PermissionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PermissionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PermissionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PermissionValidationError) ErrorName() string { return "PermissionValidationError" }

// Error satisfies the builtin error interface
func (e PermissionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPermission.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PermissionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PermissionValidationError{}

// Validate checks the field values on Role with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Role) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Role with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in RoleMultiError, or nil if none found.
func (m *Role) ValidateAll() error {
	return m.validate(true)
}

func (m *Role) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetName()) < 3 {
		err := RoleValidationError{
			field:  "Name",
			reason: "value length must be at least 3 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetPerms() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RoleValidationError{
						field:  fmt.Sprintf("Perms[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RoleValidationError{
						field:  fmt.Sprintf("Perms[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RoleValidationError{
					field:  fmt.Sprintf("Perms[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Id

	if len(errors) > 0 {
		return RoleMultiError(errors)
	}

	return nil
}

// RoleMultiError is an error wrapping multiple validation errors returned by
// Role.ValidateAll() if the designated constraints aren't met.
type RoleMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RoleMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RoleMultiError) AllErrors() []error { return m }

// RoleValidationError is the validation error returned by Role.Validate if the
// designated constraints aren't met.
type RoleValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RoleValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RoleValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RoleValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RoleValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RoleValidationError) ErrorName() string { return "RoleValidationError" }

// Error satisfies the builtin error interface
func (e RoleValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRole.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RoleValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RoleValidationError{}

// Validate checks the field values on User with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *User) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on User with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in UserMultiError, or nil if none found.
func (m *User) ValidateAll() error {
	return m.validate(true)
}

func (m *User) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if utf8.RuneCountInString(m.GetName()) < 3 {
		err := UserValidationError{
			field:  "Name",
			reason: "value length must be at least 3 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if err := m._validateEmail(m.GetEmail()); err != nil {
		err = UserValidationError{
			field:  "Email",
			reason: "value must be a valid email address",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetRoles() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UserValidationError{
						field:  fmt.Sprintf("Roles[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UserValidationError{
						field:  fmt.Sprintf("Roles[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UserValidationError{
					field:  fmt.Sprintf("Roles[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Blocked

	if len(errors) > 0 {
		return UserMultiError(errors)
	}

	return nil
}

func (m *User) _validateHostname(host string) error {
	s := strings.ToLower(strings.TrimSuffix(host, "."))

	if len(host) > 253 {
		return errors.New("hostname cannot exceed 253 characters")
	}

	for _, part := range strings.Split(s, ".") {
		if l := len(part); l == 0 || l > 63 {
			return errors.New("hostname part must be non-empty and cannot exceed 63 characters")
		}

		if part[0] == '-' {
			return errors.New("hostname parts cannot begin with hyphens")
		}

		if part[len(part)-1] == '-' {
			return errors.New("hostname parts cannot end with hyphens")
		}

		for _, r := range part {
			if (r < 'a' || r > 'z') && (r < '0' || r > '9') && r != '-' {
				return fmt.Errorf("hostname parts can only contain alphanumeric characters or hyphens, got %q", string(r))
			}
		}
	}

	return nil
}

func (m *User) _validateEmail(addr string) error {
	a, err := mail.ParseAddress(addr)
	if err != nil {
		return err
	}
	addr = a.Address

	if len(addr) > 254 {
		return errors.New("email addresses cannot exceed 254 characters")
	}

	parts := strings.SplitN(addr, "@", 2)

	if len(parts[0]) > 64 {
		return errors.New("email address local phrase cannot exceed 64 characters")
	}

	return m._validateHostname(parts[1])
}

// UserMultiError is an error wrapping multiple validation errors returned by
// User.ValidateAll() if the designated constraints aren't met.
type UserMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserMultiError) AllErrors() []error { return m }

// UserValidationError is the validation error returned by User.Validate if the
// designated constraints aren't met.
type UserValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserValidationError) ErrorName() string { return "UserValidationError" }

// Error satisfies the builtin error interface
func (e UserValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUser.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserValidationError{}

// Validate checks the field values on GetUserByIdRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetUserByIdRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetUserByIdRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetUserByIdRequestMultiError, or nil if none found.
func (m *GetUserByIdRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetUserByIdRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Jwt

	if len(errors) > 0 {
		return GetUserByIdRequestMultiError(errors)
	}

	return nil
}

// GetUserByIdRequestMultiError is an error wrapping multiple validation errors
// returned by GetUserByIdRequest.ValidateAll() if the designated constraints
// aren't met.
type GetUserByIdRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetUserByIdRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetUserByIdRequestMultiError) AllErrors() []error { return m }

// GetUserByIdRequestValidationError is the validation error returned by
// GetUserByIdRequest.Validate if the designated constraints aren't met.
type GetUserByIdRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetUserByIdRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetUserByIdRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetUserByIdRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetUserByIdRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetUserByIdRequestValidationError) ErrorName() string {
	return "GetUserByIdRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetUserByIdRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetUserByIdRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetUserByIdRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetUserByIdRequestValidationError{}

// Validate checks the field values on GetUserByIdResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetUserByIdResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetUserByIdResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetUserByIdResponseMultiError, or nil if none found.
func (m *GetUserByIdResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetUserByIdResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Success

	if all {
		switch v := interface{}(m.GetUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetUserByIdResponseValidationError{
					field:  "User",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetUserByIdResponseValidationError{
					field:  "User",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetUserByIdResponseValidationError{
				field:  "User",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Message

	// no validation rules for Error

	if len(errors) > 0 {
		return GetUserByIdResponseMultiError(errors)
	}

	return nil
}

// GetUserByIdResponseMultiError is an error wrapping multiple validation
// errors returned by GetUserByIdResponse.ValidateAll() if the designated
// constraints aren't met.
type GetUserByIdResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetUserByIdResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetUserByIdResponseMultiError) AllErrors() []error { return m }

// GetUserByIdResponseValidationError is the validation error returned by
// GetUserByIdResponse.Validate if the designated constraints aren't met.
type GetUserByIdResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetUserByIdResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetUserByIdResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetUserByIdResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetUserByIdResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetUserByIdResponseValidationError) ErrorName() string {
	return "GetUserByIdResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetUserByIdResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetUserByIdResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetUserByIdResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetUserByIdResponseValidationError{}

// Validate checks the field values on GetUserByEmailRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetUserByEmailRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetUserByEmailRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetUserByEmailRequestMultiError, or nil if none found.
func (m *GetUserByEmailRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetUserByEmailRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if err := m._validateEmail(m.GetEmail()); err != nil {
		err = GetUserByEmailRequestValidationError{
			field:  "Email",
			reason: "value must be a valid email address",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Jwt

	if len(errors) > 0 {
		return GetUserByEmailRequestMultiError(errors)
	}

	return nil
}

func (m *GetUserByEmailRequest) _validateHostname(host string) error {
	s := strings.ToLower(strings.TrimSuffix(host, "."))

	if len(host) > 253 {
		return errors.New("hostname cannot exceed 253 characters")
	}

	for _, part := range strings.Split(s, ".") {
		if l := len(part); l == 0 || l > 63 {
			return errors.New("hostname part must be non-empty and cannot exceed 63 characters")
		}

		if part[0] == '-' {
			return errors.New("hostname parts cannot begin with hyphens")
		}

		if part[len(part)-1] == '-' {
			return errors.New("hostname parts cannot end with hyphens")
		}

		for _, r := range part {
			if (r < 'a' || r > 'z') && (r < '0' || r > '9') && r != '-' {
				return fmt.Errorf("hostname parts can only contain alphanumeric characters or hyphens, got %q", string(r))
			}
		}
	}

	return nil
}

func (m *GetUserByEmailRequest) _validateEmail(addr string) error {
	a, err := mail.ParseAddress(addr)
	if err != nil {
		return err
	}
	addr = a.Address

	if len(addr) > 254 {
		return errors.New("email addresses cannot exceed 254 characters")
	}

	parts := strings.SplitN(addr, "@", 2)

	if len(parts[0]) > 64 {
		return errors.New("email address local phrase cannot exceed 64 characters")
	}

	return m._validateHostname(parts[1])
}

// GetUserByEmailRequestMultiError is an error wrapping multiple validation
// errors returned by GetUserByEmailRequest.ValidateAll() if the designated
// constraints aren't met.
type GetUserByEmailRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetUserByEmailRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetUserByEmailRequestMultiError) AllErrors() []error { return m }

// GetUserByEmailRequestValidationError is the validation error returned by
// GetUserByEmailRequest.Validate if the designated constraints aren't met.
type GetUserByEmailRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetUserByEmailRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetUserByEmailRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetUserByEmailRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetUserByEmailRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetUserByEmailRequestValidationError) ErrorName() string {
	return "GetUserByEmailRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetUserByEmailRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetUserByEmailRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetUserByEmailRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetUserByEmailRequestValidationError{}

// Validate checks the field values on GetUserByEmailResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetUserByEmailResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetUserByEmailResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetUserByEmailResponseMultiError, or nil if none found.
func (m *GetUserByEmailResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetUserByEmailResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Success

	if all {
		switch v := interface{}(m.GetUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetUserByEmailResponseValidationError{
					field:  "User",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetUserByEmailResponseValidationError{
					field:  "User",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetUserByEmailResponseValidationError{
				field:  "User",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Message

	// no validation rules for Error

	if len(errors) > 0 {
		return GetUserByEmailResponseMultiError(errors)
	}

	return nil
}

// GetUserByEmailResponseMultiError is an error wrapping multiple validation
// errors returned by GetUserByEmailResponse.ValidateAll() if the designated
// constraints aren't met.
type GetUserByEmailResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetUserByEmailResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetUserByEmailResponseMultiError) AllErrors() []error { return m }

// GetUserByEmailResponseValidationError is the validation error returned by
// GetUserByEmailResponse.Validate if the designated constraints aren't met.
type GetUserByEmailResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetUserByEmailResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetUserByEmailResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetUserByEmailResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetUserByEmailResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetUserByEmailResponseValidationError) ErrorName() string {
	return "GetUserByEmailResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetUserByEmailResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetUserByEmailResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetUserByEmailResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetUserByEmailResponseValidationError{}

// Validate checks the field values on DeleteUserRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DeleteUserRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteUserRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteUserRequestMultiError, or nil if none found.
func (m *DeleteUserRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteUserRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Jwt

	if len(errors) > 0 {
		return DeleteUserRequestMultiError(errors)
	}

	return nil
}

// DeleteUserRequestMultiError is an error wrapping multiple validation errors
// returned by DeleteUserRequest.ValidateAll() if the designated constraints
// aren't met.
type DeleteUserRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteUserRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteUserRequestMultiError) AllErrors() []error { return m }

// DeleteUserRequestValidationError is the validation error returned by
// DeleteUserRequest.Validate if the designated constraints aren't met.
type DeleteUserRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteUserRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteUserRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteUserRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteUserRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteUserRequestValidationError) ErrorName() string {
	return "DeleteUserRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteUserRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteUserRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteUserRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteUserRequestValidationError{}

// Validate checks the field values on DeleteUserResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteUserResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteUserResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteUserResponseMultiError, or nil if none found.
func (m *DeleteUserResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteUserResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Success

	// no validation rules for Message

	// no validation rules for Error

	if len(errors) > 0 {
		return DeleteUserResponseMultiError(errors)
	}

	return nil
}

// DeleteUserResponseMultiError is an error wrapping multiple validation errors
// returned by DeleteUserResponse.ValidateAll() if the designated constraints
// aren't met.
type DeleteUserResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteUserResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteUserResponseMultiError) AllErrors() []error { return m }

// DeleteUserResponseValidationError is the validation error returned by
// DeleteUserResponse.Validate if the designated constraints aren't met.
type DeleteUserResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteUserResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteUserResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteUserResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteUserResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteUserResponseValidationError) ErrorName() string {
	return "DeleteUserResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteUserResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteUserResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteUserResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteUserResponseValidationError{}

// Validate checks the field values on GetAllUsersRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetAllUsersRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetAllUsersRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetAllUsersRequestMultiError, or nil if none found.
func (m *GetAllUsersRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetAllUsersRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Jwt

	if len(errors) > 0 {
		return GetAllUsersRequestMultiError(errors)
	}

	return nil
}

// GetAllUsersRequestMultiError is an error wrapping multiple validation errors
// returned by GetAllUsersRequest.ValidateAll() if the designated constraints
// aren't met.
type GetAllUsersRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetAllUsersRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetAllUsersRequestMultiError) AllErrors() []error { return m }

// GetAllUsersRequestValidationError is the validation error returned by
// GetAllUsersRequest.Validate if the designated constraints aren't met.
type GetAllUsersRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetAllUsersRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetAllUsersRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetAllUsersRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetAllUsersRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetAllUsersRequestValidationError) ErrorName() string {
	return "GetAllUsersRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetAllUsersRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetAllUsersRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetAllUsersRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetAllUsersRequestValidationError{}

// Validate checks the field values on GetAllUsersResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetAllUsersResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetAllUsersResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetAllUsersResponseMultiError, or nil if none found.
func (m *GetAllUsersResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetAllUsersResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Success

	for idx, item := range m.GetUsers() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetAllUsersResponseValidationError{
						field:  fmt.Sprintf("Users[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetAllUsersResponseValidationError{
						field:  fmt.Sprintf("Users[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetAllUsersResponseValidationError{
					field:  fmt.Sprintf("Users[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Message

	// no validation rules for Error

	if len(errors) > 0 {
		return GetAllUsersResponseMultiError(errors)
	}

	return nil
}

// GetAllUsersResponseMultiError is an error wrapping multiple validation
// errors returned by GetAllUsersResponse.ValidateAll() if the designated
// constraints aren't met.
type GetAllUsersResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetAllUsersResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetAllUsersResponseMultiError) AllErrors() []error { return m }

// GetAllUsersResponseValidationError is the validation error returned by
// GetAllUsersResponse.Validate if the designated constraints aren't met.
type GetAllUsersResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetAllUsersResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetAllUsersResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetAllUsersResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetAllUsersResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetAllUsersResponseValidationError) ErrorName() string {
	return "GetAllUsersResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetAllUsersResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetAllUsersResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetAllUsersResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetAllUsersResponseValidationError{}

// Validate checks the field values on GetUsersByRoleRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetUsersByRoleRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetUsersByRoleRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetUsersByRoleRequestMultiError, or nil if none found.
func (m *GetUsersByRoleRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetUsersByRoleRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetRoleName()) < 3 {
		err := GetUsersByRoleRequestValidationError{
			field:  "RoleName",
			reason: "value length must be at least 3 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Jwt

	if len(errors) > 0 {
		return GetUsersByRoleRequestMultiError(errors)
	}

	return nil
}

// GetUsersByRoleRequestMultiError is an error wrapping multiple validation
// errors returned by GetUsersByRoleRequest.ValidateAll() if the designated
// constraints aren't met.
type GetUsersByRoleRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetUsersByRoleRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetUsersByRoleRequestMultiError) AllErrors() []error { return m }

// GetUsersByRoleRequestValidationError is the validation error returned by
// GetUsersByRoleRequest.Validate if the designated constraints aren't met.
type GetUsersByRoleRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetUsersByRoleRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetUsersByRoleRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetUsersByRoleRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetUsersByRoleRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetUsersByRoleRequestValidationError) ErrorName() string {
	return "GetUsersByRoleRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetUsersByRoleRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetUsersByRoleRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetUsersByRoleRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetUsersByRoleRequestValidationError{}

// Validate checks the field values on GetUsersByRoleResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetUsersByRoleResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetUsersByRoleResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetUsersByRoleResponseMultiError, or nil if none found.
func (m *GetUsersByRoleResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetUsersByRoleResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Success

	for idx, item := range m.GetUsers() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetUsersByRoleResponseValidationError{
						field:  fmt.Sprintf("Users[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetUsersByRoleResponseValidationError{
						field:  fmt.Sprintf("Users[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetUsersByRoleResponseValidationError{
					field:  fmt.Sprintf("Users[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Message

	// no validation rules for Error

	if len(errors) > 0 {
		return GetUsersByRoleResponseMultiError(errors)
	}

	return nil
}

// GetUsersByRoleResponseMultiError is an error wrapping multiple validation
// errors returned by GetUsersByRoleResponse.ValidateAll() if the designated
// constraints aren't met.
type GetUsersByRoleResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetUsersByRoleResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetUsersByRoleResponseMultiError) AllErrors() []error { return m }

// GetUsersByRoleResponseValidationError is the validation error returned by
// GetUsersByRoleResponse.Validate if the designated constraints aren't met.
type GetUsersByRoleResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetUsersByRoleResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetUsersByRoleResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetUsersByRoleResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetUsersByRoleResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetUsersByRoleResponseValidationError) ErrorName() string {
	return "GetUsersByRoleResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetUsersByRoleResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetUsersByRoleResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetUsersByRoleResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetUsersByRoleResponseValidationError{}

// Validate checks the field values on AddUserRolesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AddUserRolesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AddUserRolesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AddUserRolesRequestMultiError, or nil if none found.
func (m *AddUserRolesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *AddUserRolesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Jwt

	if len(errors) > 0 {
		return AddUserRolesRequestMultiError(errors)
	}

	return nil
}

// AddUserRolesRequestMultiError is an error wrapping multiple validation
// errors returned by AddUserRolesRequest.ValidateAll() if the designated
// constraints aren't met.
type AddUserRolesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AddUserRolesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AddUserRolesRequestMultiError) AllErrors() []error { return m }

// AddUserRolesRequestValidationError is the validation error returned by
// AddUserRolesRequest.Validate if the designated constraints aren't met.
type AddUserRolesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AddUserRolesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AddUserRolesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AddUserRolesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AddUserRolesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AddUserRolesRequestValidationError) ErrorName() string {
	return "AddUserRolesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e AddUserRolesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAddUserRolesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AddUserRolesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AddUserRolesRequestValidationError{}

// Validate checks the field values on AddUserRolesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AddUserRolesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AddUserRolesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AddUserRolesResponseMultiError, or nil if none found.
func (m *AddUserRolesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *AddUserRolesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Success

	// no validation rules for Message

	// no validation rules for Error

	if len(errors) > 0 {
		return AddUserRolesResponseMultiError(errors)
	}

	return nil
}

// AddUserRolesResponseMultiError is an error wrapping multiple validation
// errors returned by AddUserRolesResponse.ValidateAll() if the designated
// constraints aren't met.
type AddUserRolesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AddUserRolesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AddUserRolesResponseMultiError) AllErrors() []error { return m }

// AddUserRolesResponseValidationError is the validation error returned by
// AddUserRolesResponse.Validate if the designated constraints aren't met.
type AddUserRolesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AddUserRolesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AddUserRolesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AddUserRolesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AddUserRolesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AddUserRolesResponseValidationError) ErrorName() string {
	return "AddUserRolesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e AddUserRolesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAddUserRolesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AddUserRolesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AddUserRolesResponseValidationError{}

// Validate checks the field values on RemoveUserRolesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RemoveUserRolesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RemoveUserRolesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RemoveUserRolesRequestMultiError, or nil if none found.
func (m *RemoveUserRolesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *RemoveUserRolesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Jwt

	if len(errors) > 0 {
		return RemoveUserRolesRequestMultiError(errors)
	}

	return nil
}

// RemoveUserRolesRequestMultiError is an error wrapping multiple validation
// errors returned by RemoveUserRolesRequest.ValidateAll() if the designated
// constraints aren't met.
type RemoveUserRolesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RemoveUserRolesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RemoveUserRolesRequestMultiError) AllErrors() []error { return m }

// RemoveUserRolesRequestValidationError is the validation error returned by
// RemoveUserRolesRequest.Validate if the designated constraints aren't met.
type RemoveUserRolesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RemoveUserRolesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RemoveUserRolesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RemoveUserRolesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RemoveUserRolesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RemoveUserRolesRequestValidationError) ErrorName() string {
	return "RemoveUserRolesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e RemoveUserRolesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRemoveUserRolesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RemoveUserRolesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RemoveUserRolesRequestValidationError{}

// Validate checks the field values on RemoveUserRolesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RemoveUserRolesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RemoveUserRolesResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RemoveUserRolesResponseMultiError, or nil if none found.
func (m *RemoveUserRolesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *RemoveUserRolesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Success

	// no validation rules for Message

	// no validation rules for Error

	if len(errors) > 0 {
		return RemoveUserRolesResponseMultiError(errors)
	}

	return nil
}

// RemoveUserRolesResponseMultiError is an error wrapping multiple validation
// errors returned by RemoveUserRolesResponse.ValidateAll() if the designated
// constraints aren't met.
type RemoveUserRolesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RemoveUserRolesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RemoveUserRolesResponseMultiError) AllErrors() []error { return m }

// RemoveUserRolesResponseValidationError is the validation error returned by
// RemoveUserRolesResponse.Validate if the designated constraints aren't met.
type RemoveUserRolesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RemoveUserRolesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RemoveUserRolesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RemoveUserRolesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RemoveUserRolesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RemoveUserRolesResponseValidationError) ErrorName() string {
	return "RemoveUserRolesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e RemoveUserRolesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRemoveUserRolesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RemoveUserRolesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RemoveUserRolesResponseValidationError{}

// Validate checks the field values on AuthenticateRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AuthenticateRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AuthenticateRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AuthenticateRequestMultiError, or nil if none found.
func (m *AuthenticateRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *AuthenticateRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if err := m._validateEmail(m.GetEmail()); err != nil {
		err = AuthenticateRequestValidationError{
			field:  "Email",
			reason: "value must be a valid email address",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetPassword()) < 8 {
		err := AuthenticateRequestValidationError{
			field:  "Password",
			reason: "value length must be at least 8 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Jwt

	if len(errors) > 0 {
		return AuthenticateRequestMultiError(errors)
	}

	return nil
}

func (m *AuthenticateRequest) _validateHostname(host string) error {
	s := strings.ToLower(strings.TrimSuffix(host, "."))

	if len(host) > 253 {
		return errors.New("hostname cannot exceed 253 characters")
	}

	for _, part := range strings.Split(s, ".") {
		if l := len(part); l == 0 || l > 63 {
			return errors.New("hostname part must be non-empty and cannot exceed 63 characters")
		}

		if part[0] == '-' {
			return errors.New("hostname parts cannot begin with hyphens")
		}

		if part[len(part)-1] == '-' {
			return errors.New("hostname parts cannot end with hyphens")
		}

		for _, r := range part {
			if (r < 'a' || r > 'z') && (r < '0' || r > '9') && r != '-' {
				return fmt.Errorf("hostname parts can only contain alphanumeric characters or hyphens, got %q", string(r))
			}
		}
	}

	return nil
}

func (m *AuthenticateRequest) _validateEmail(addr string) error {
	a, err := mail.ParseAddress(addr)
	if err != nil {
		return err
	}
	addr = a.Address

	if len(addr) > 254 {
		return errors.New("email addresses cannot exceed 254 characters")
	}

	parts := strings.SplitN(addr, "@", 2)

	if len(parts[0]) > 64 {
		return errors.New("email address local phrase cannot exceed 64 characters")
	}

	return m._validateHostname(parts[1])
}

// AuthenticateRequestMultiError is an error wrapping multiple validation
// errors returned by AuthenticateRequest.ValidateAll() if the designated
// constraints aren't met.
type AuthenticateRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AuthenticateRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AuthenticateRequestMultiError) AllErrors() []error { return m }

// AuthenticateRequestValidationError is the validation error returned by
// AuthenticateRequest.Validate if the designated constraints aren't met.
type AuthenticateRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AuthenticateRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AuthenticateRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AuthenticateRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AuthenticateRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AuthenticateRequestValidationError) ErrorName() string {
	return "AuthenticateRequestValidationError"
}

// Error satisfies the builtin error interface
func (e AuthenticateRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAuthenticateRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AuthenticateRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AuthenticateRequestValidationError{}

// Validate checks the field values on AuthenticateResult with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AuthenticateResult) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AuthenticateResult with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AuthenticateResultMultiError, or nil if none found.
func (m *AuthenticateResult) ValidateAll() error {
	return m.validate(true)
}

func (m *AuthenticateResult) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UserID

	if utf8.RuneCountInString(m.GetName()) < 3 {
		err := AuthenticateResultValidationError{
			field:  "Name",
			reason: "value length must be at least 3 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetRoles() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AuthenticateResultValidationError{
						field:  fmt.Sprintf("Roles[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AuthenticateResultValidationError{
						field:  fmt.Sprintf("Roles[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AuthenticateResultValidationError{
					field:  fmt.Sprintf("Roles[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return AuthenticateResultMultiError(errors)
	}

	return nil
}

// AuthenticateResultMultiError is an error wrapping multiple validation errors
// returned by AuthenticateResult.ValidateAll() if the designated constraints
// aren't met.
type AuthenticateResultMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AuthenticateResultMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AuthenticateResultMultiError) AllErrors() []error { return m }

// AuthenticateResultValidationError is the validation error returned by
// AuthenticateResult.Validate if the designated constraints aren't met.
type AuthenticateResultValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AuthenticateResultValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AuthenticateResultValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AuthenticateResultValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AuthenticateResultValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AuthenticateResultValidationError) ErrorName() string {
	return "AuthenticateResultValidationError"
}

// Error satisfies the builtin error interface
func (e AuthenticateResultValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAuthenticateResult.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AuthenticateResultValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AuthenticateResultValidationError{}

// Validate checks the field values on AuthenticateResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AuthenticateResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AuthenticateResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AuthenticateResponseMultiError, or nil if none found.
func (m *AuthenticateResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *AuthenticateResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Success

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AuthenticateResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AuthenticateResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AuthenticateResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Message

	// no validation rules for Error

	if len(errors) > 0 {
		return AuthenticateResponseMultiError(errors)
	}

	return nil
}

// AuthenticateResponseMultiError is an error wrapping multiple validation
// errors returned by AuthenticateResponse.ValidateAll() if the designated
// constraints aren't met.
type AuthenticateResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AuthenticateResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AuthenticateResponseMultiError) AllErrors() []error { return m }

// AuthenticateResponseValidationError is the validation error returned by
// AuthenticateResponse.Validate if the designated constraints aren't met.
type AuthenticateResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AuthenticateResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AuthenticateResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AuthenticateResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AuthenticateResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AuthenticateResponseValidationError) ErrorName() string {
	return "AuthenticateResponseValidationError"
}

// Error satisfies the builtin error interface
func (e AuthenticateResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAuthenticateResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AuthenticateResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AuthenticateResponseValidationError{}

// Validate checks the field values on BlockUserRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *BlockUserRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BlockUserRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BlockUserRequestMultiError, or nil if none found.
func (m *BlockUserRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *BlockUserRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UserId

	// no validation rules for Jwt

	if len(errors) > 0 {
		return BlockUserRequestMultiError(errors)
	}

	return nil
}

// BlockUserRequestMultiError is an error wrapping multiple validation errors
// returned by BlockUserRequest.ValidateAll() if the designated constraints
// aren't met.
type BlockUserRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BlockUserRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BlockUserRequestMultiError) AllErrors() []error { return m }

// BlockUserRequestValidationError is the validation error returned by
// BlockUserRequest.Validate if the designated constraints aren't met.
type BlockUserRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BlockUserRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BlockUserRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BlockUserRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BlockUserRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BlockUserRequestValidationError) ErrorName() string { return "BlockUserRequestValidationError" }

// Error satisfies the builtin error interface
func (e BlockUserRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBlockUserRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BlockUserRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BlockUserRequestValidationError{}

// Validate checks the field values on BlockUserResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *BlockUserResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BlockUserResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BlockUserResponseMultiError, or nil if none found.
func (m *BlockUserResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *BlockUserResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Success

	// no validation rules for Message

	// no validation rules for Error

	if len(errors) > 0 {
		return BlockUserResponseMultiError(errors)
	}

	return nil
}

// BlockUserResponseMultiError is an error wrapping multiple validation errors
// returned by BlockUserResponse.ValidateAll() if the designated constraints
// aren't met.
type BlockUserResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BlockUserResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BlockUserResponseMultiError) AllErrors() []error { return m }

// BlockUserResponseValidationError is the validation error returned by
// BlockUserResponse.Validate if the designated constraints aren't met.
type BlockUserResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BlockUserResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BlockUserResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BlockUserResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BlockUserResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BlockUserResponseValidationError) ErrorName() string {
	return "BlockUserResponseValidationError"
}

// Error satisfies the builtin error interface
func (e BlockUserResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBlockUserResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BlockUserResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BlockUserResponseValidationError{}

// Validate checks the field values on UnBlockUserRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UnBlockUserRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UnBlockUserRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UnBlockUserRequestMultiError, or nil if none found.
func (m *UnBlockUserRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UnBlockUserRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UserId

	// no validation rules for Jwt

	if len(errors) > 0 {
		return UnBlockUserRequestMultiError(errors)
	}

	return nil
}

// UnBlockUserRequestMultiError is an error wrapping multiple validation errors
// returned by UnBlockUserRequest.ValidateAll() if the designated constraints
// aren't met.
type UnBlockUserRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UnBlockUserRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UnBlockUserRequestMultiError) AllErrors() []error { return m }

// UnBlockUserRequestValidationError is the validation error returned by
// UnBlockUserRequest.Validate if the designated constraints aren't met.
type UnBlockUserRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UnBlockUserRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UnBlockUserRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UnBlockUserRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UnBlockUserRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UnBlockUserRequestValidationError) ErrorName() string {
	return "UnBlockUserRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UnBlockUserRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUnBlockUserRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UnBlockUserRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UnBlockUserRequestValidationError{}

// Validate checks the field values on UnBlockUserResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UnBlockUserResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UnBlockUserResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UnBlockUserResponseMultiError, or nil if none found.
func (m *UnBlockUserResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UnBlockUserResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Success

	// no validation rules for Message

	// no validation rules for Error

	if len(errors) > 0 {
		return UnBlockUserResponseMultiError(errors)
	}

	return nil
}

// UnBlockUserResponseMultiError is an error wrapping multiple validation
// errors returned by UnBlockUserResponse.ValidateAll() if the designated
// constraints aren't met.
type UnBlockUserResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UnBlockUserResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UnBlockUserResponseMultiError) AllErrors() []error { return m }

// UnBlockUserResponseValidationError is the validation error returned by
// UnBlockUserResponse.Validate if the designated constraints aren't met.
type UnBlockUserResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UnBlockUserResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UnBlockUserResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UnBlockUserResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UnBlockUserResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UnBlockUserResponseValidationError) ErrorName() string {
	return "UnBlockUserResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UnBlockUserResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUnBlockUserResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UnBlockUserResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UnBlockUserResponseValidationError{}
